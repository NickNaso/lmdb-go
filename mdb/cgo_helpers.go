// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 05 Sep 2016 13:16:14 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package mdb

/*
#cgo linux CFLAGS: -DMDB_USE_SYSV_SEM=1
#cgo windows LDFLAGS: -lntdll
#include "lmdb.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Env) Ref() *C.MDB_env {
	if x == nil {
		return nil
	}
	return (*C.MDB_env)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Env) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEnvRef converts the C object reference into a raw struct reference without wrapping.
func NewEnvRef(ref *C.MDB_env) *Env {
	return (*Env)(unsafe.Pointer(ref))
}

// NewEnv allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEnv() *Env {
	return (*Env)(allocEnvMemory(1))
}

// allocEnvMemory allocates memory for type C.MDB_env in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEnvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEnvValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEnvValue = unsafe.Sizeof([1]C.MDB_env{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Env) PassRef() *C.MDB_env {
	if x == nil {
		x = (*Env)(allocEnvMemory(1))
	}
	return (*C.MDB_env)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Txn) Ref() *C.MDB_txn {
	if x == nil {
		return nil
	}
	return (*C.MDB_txn)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Txn) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTxnRef converts the C object reference into a raw struct reference without wrapping.
func NewTxnRef(ref *C.MDB_txn) *Txn {
	return (*Txn)(unsafe.Pointer(ref))
}

// NewTxn allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTxn() *Txn {
	return (*Txn)(allocTxnMemory(1))
}

// allocTxnMemory allocates memory for type C.MDB_txn in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTxnMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTxnValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTxnValue = unsafe.Sizeof([1]C.MDB_txn{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Txn) PassRef() *C.MDB_txn {
	if x == nil {
		x = (*Txn)(allocTxnMemory(1))
	}
	return (*C.MDB_txn)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Cursor) Ref() *C.MDB_cursor {
	if x == nil {
		return nil
	}
	return (*C.MDB_cursor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Cursor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCursorRef converts the C object reference into a raw struct reference without wrapping.
func NewCursorRef(ref *C.MDB_cursor) *Cursor {
	return (*Cursor)(unsafe.Pointer(ref))
}

// NewCursor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCursor() *Cursor {
	return (*Cursor)(allocCursorMemory(1))
}

// allocCursorMemory allocates memory for type C.MDB_cursor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCursorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCursorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCursorValue = unsafe.Sizeof([1]C.MDB_cursor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Cursor) PassRef() *C.MDB_cursor {
	if x == nil {
		x = (*Cursor)(allocCursorMemory(1))
	}
	return (*C.MDB_cursor)(unsafe.Pointer(x))
}

// allocValMemory allocates memory for type C.MDB_val in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValValue = unsafe.Sizeof([1]C.MDB_val{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Val) Ref() *C.MDB_val {
	if x == nil {
		return nil
	}
	return x.reff5baf417
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Val) Free() {
	if x != nil && x.allocsf5baf417 != nil {
		x.allocsf5baf417.(*cgoAllocMap).Free()
		x.reff5baf417 = nil
	}
}

// NewValRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValRef(ref unsafe.Pointer) *Val {
	if ref == nil {
		return nil
	}
	obj := new(Val)
	obj.reff5baf417 = (*C.MDB_val)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Val) PassRef() (*C.MDB_val, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff5baf417 != nil {
		return x.reff5baf417, nil
	}
	memf5baf417 := allocValMemory(1)
	reff5baf417 := (*C.MDB_val)(memf5baf417)
	allocsf5baf417 := new(cgoAllocMap)
	var cmv_size_allocs *cgoAllocMap
	reff5baf417.mv_size, cmv_size_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocsf5baf417.Borrow(cmv_size_allocs)

	var cmv_data_allocs *cgoAllocMap
	reff5baf417.mv_data, cmv_data_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsf5baf417.Borrow(cmv_data_allocs)

	x.reff5baf417 = reff5baf417
	x.allocsf5baf417 = allocsf5baf417
	return reff5baf417, allocsf5baf417

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Val) PassValue() (C.MDB_val, *cgoAllocMap) {
	if x.reff5baf417 != nil {
		return *x.reff5baf417, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Val) Deref() {
	if x.reff5baf417 == nil {
		return
	}
	x.Size = (uint)(x.reff5baf417.mv_size)
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.reff5baf417.mv_data))
}

func (x CmpFunc) PassRef() (ref *C.MDB_cmp_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmpFuncE2FAE82FFunc == nil {
		cmpFuncE2FAE82FFunc = x
	}
	return (*C.MDB_cmp_func)(C.MDB_cmp_func_e2fae82f), nil
}

//export cmpFuncE2FAE82F
func cmpFuncE2FAE82F(ca *C.MDB_val, cb *C.MDB_val) C.int {
	if cmpFuncE2FAE82FFunc != nil {
		ae2fae82f := NewValRef(unsafe.Pointer(ca))
		be2fae82f := NewValRef(unsafe.Pointer(cb))
		rete2fae82f := cmpFuncE2FAE82FFunc(ae2fae82f, be2fae82f)
		ret, _ := (C.int)(rete2fae82f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var cmpFuncE2FAE82FFunc CmpFunc

func (x RelFunc) PassRef() (ref *C.MDB_rel_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if relFunc1510551DFunc == nil {
		relFunc1510551DFunc = x
	}
	return (*C.MDB_rel_func)(C.MDB_rel_func_1510551d), nil
}

//export relFunc1510551D
func relFunc1510551D(citem *C.MDB_val, coldptr unsafe.Pointer, cnewptr unsafe.Pointer, crelctx unsafe.Pointer) {
	if relFunc1510551DFunc != nil {
		item1510551d := NewValRef(unsafe.Pointer(citem))
		oldptr1510551d := (unsafe.Pointer)(unsafe.Pointer(coldptr))
		newptr1510551d := (unsafe.Pointer)(unsafe.Pointer(cnewptr))
		relctx1510551d := (unsafe.Pointer)(unsafe.Pointer(crelctx))
		relFunc1510551DFunc(item1510551d, oldptr1510551d, newptr1510551d, relctx1510551d)
		return
	}
	panic("callback func has not been set (race?)")
}

var relFunc1510551DFunc RelFunc

// allocStatsMemory allocates memory for type C.MDB_stat in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStatsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStatsValue = unsafe.Sizeof([1]C.MDB_stat{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Stats) Ref() *C.MDB_stat {
	if x == nil {
		return nil
	}
	return x.ref9ed18a7f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Stats) Free() {
	if x != nil && x.allocs9ed18a7f != nil {
		x.allocs9ed18a7f.(*cgoAllocMap).Free()
		x.ref9ed18a7f = nil
	}
}

// NewStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStatsRef(ref unsafe.Pointer) *Stats {
	if ref == nil {
		return nil
	}
	obj := new(Stats)
	obj.ref9ed18a7f = (*C.MDB_stat)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Stats) PassRef() (*C.MDB_stat, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9ed18a7f != nil {
		return x.ref9ed18a7f, nil
	}
	mem9ed18a7f := allocStatsMemory(1)
	ref9ed18a7f := (*C.MDB_stat)(mem9ed18a7f)
	allocs9ed18a7f := new(cgoAllocMap)
	var cms_psize_allocs *cgoAllocMap
	ref9ed18a7f.ms_psize, cms_psize_allocs = (C.uint)(x.Psize), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_psize_allocs)

	var cms_depth_allocs *cgoAllocMap
	ref9ed18a7f.ms_depth, cms_depth_allocs = (C.uint)(x.Depth), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_depth_allocs)

	var cms_branch_pages_allocs *cgoAllocMap
	ref9ed18a7f.ms_branch_pages, cms_branch_pages_allocs = (C.mdb_size_t)(x.BranchPages), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_branch_pages_allocs)

	var cms_leaf_pages_allocs *cgoAllocMap
	ref9ed18a7f.ms_leaf_pages, cms_leaf_pages_allocs = (C.mdb_size_t)(x.LeafPages), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_leaf_pages_allocs)

	var cms_overflow_pages_allocs *cgoAllocMap
	ref9ed18a7f.ms_overflow_pages, cms_overflow_pages_allocs = (C.mdb_size_t)(x.OverflowPages), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_overflow_pages_allocs)

	var cms_entries_allocs *cgoAllocMap
	ref9ed18a7f.ms_entries, cms_entries_allocs = (C.mdb_size_t)(x.Entries), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_entries_allocs)

	x.ref9ed18a7f = ref9ed18a7f
	x.allocs9ed18a7f = allocs9ed18a7f
	return ref9ed18a7f, allocs9ed18a7f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Stats) PassValue() (C.MDB_stat, *cgoAllocMap) {
	if x.ref9ed18a7f != nil {
		return *x.ref9ed18a7f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Stats) Deref() {
	if x.ref9ed18a7f == nil {
		return
	}
	x.Psize = (uint32)(x.ref9ed18a7f.ms_psize)
	x.Depth = (uint32)(x.ref9ed18a7f.ms_depth)
	x.BranchPages = (Size)(x.ref9ed18a7f.ms_branch_pages)
	x.LeafPages = (Size)(x.ref9ed18a7f.ms_leaf_pages)
	x.OverflowPages = (Size)(x.ref9ed18a7f.ms_overflow_pages)
	x.Entries = (Size)(x.ref9ed18a7f.ms_entries)
}

// allocEnvinfoMemory allocates memory for type C.MDB_envinfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEnvinfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEnvinfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEnvinfoValue = unsafe.Sizeof([1]C.MDB_envinfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Envinfo) Ref() *C.MDB_envinfo {
	if x == nil {
		return nil
	}
	return x.refea477e79
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Envinfo) Free() {
	if x != nil && x.allocsea477e79 != nil {
		x.allocsea477e79.(*cgoAllocMap).Free()
		x.refea477e79 = nil
	}
}

// NewEnvinfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEnvinfoRef(ref unsafe.Pointer) *Envinfo {
	if ref == nil {
		return nil
	}
	obj := new(Envinfo)
	obj.refea477e79 = (*C.MDB_envinfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Envinfo) PassRef() (*C.MDB_envinfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea477e79 != nil {
		return x.refea477e79, nil
	}
	memea477e79 := allocEnvinfoMemory(1)
	refea477e79 := (*C.MDB_envinfo)(memea477e79)
	allocsea477e79 := new(cgoAllocMap)
	var cme_mapaddr_allocs *cgoAllocMap
	refea477e79.me_mapaddr, cme_mapaddr_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Mapaddr)), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_mapaddr_allocs)

	var cme_mapsize_allocs *cgoAllocMap
	refea477e79.me_mapsize, cme_mapsize_allocs = (C.mdb_size_t)(x.Mapsize), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_mapsize_allocs)

	var cme_last_pgno_allocs *cgoAllocMap
	refea477e79.me_last_pgno, cme_last_pgno_allocs = (C.mdb_size_t)(x.LastPgno), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_last_pgno_allocs)

	var cme_last_txnid_allocs *cgoAllocMap
	refea477e79.me_last_txnid, cme_last_txnid_allocs = (C.mdb_size_t)(x.LastTxnid), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_last_txnid_allocs)

	var cme_maxreaders_allocs *cgoAllocMap
	refea477e79.me_maxreaders, cme_maxreaders_allocs = (C.uint)(x.Maxreaders), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_maxreaders_allocs)

	var cme_numreaders_allocs *cgoAllocMap
	refea477e79.me_numreaders, cme_numreaders_allocs = (C.uint)(x.Numreaders), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_numreaders_allocs)

	x.refea477e79 = refea477e79
	x.allocsea477e79 = allocsea477e79
	return refea477e79, allocsea477e79

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Envinfo) PassValue() (C.MDB_envinfo, *cgoAllocMap) {
	if x.refea477e79 != nil {
		return *x.refea477e79, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Envinfo) Deref() {
	if x.refea477e79 == nil {
		return
	}
	x.Mapaddr = (unsafe.Pointer)(unsafe.Pointer(x.refea477e79.me_mapaddr))
	x.Mapsize = (Size)(x.refea477e79.me_mapsize)
	x.LastPgno = (Size)(x.refea477e79.me_last_pgno)
	x.LastTxnid = (Size)(x.refea477e79.me_last_txnid)
	x.Maxreaders = (uint32)(x.refea477e79.me_maxreaders)
	x.Numreaders = (uint32)(x.refea477e79.me_numreaders)
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x AssertFunc) PassRef() (ref *C.MDB_assert_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if assertFuncC5B9172DFunc == nil {
		assertFuncC5B9172DFunc = x
	}
	return (*C.MDB_assert_func)(C.MDB_assert_func_c5b9172d), nil
}

//export assertFuncC5B9172D
func assertFuncC5B9172D(cenv *C.MDB_env, cmsg *C.char) {
	if assertFuncC5B9172DFunc != nil {
		envc5b9172d := (*Env)(unsafe.Pointer(cenv))
		msgc5b9172d := packPCharString(cmsg)
		assertFuncC5B9172DFunc(envc5b9172d, msgc5b9172d)
		return
	}
	panic("callback func has not been set (race?)")
}

var assertFuncC5B9172DFunc AssertFunc

func (x MsgFunc) PassRef() (ref *C.MDB_msg_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if msgFuncDE422FADFunc == nil {
		msgFuncDE422FADFunc = x
	}
	return (*C.MDB_msg_func)(C.MDB_msg_func_de422fad), nil
}

//export msgFuncDE422FAD
func msgFuncDE422FAD(cmsg *C.char, cctx unsafe.Pointer) C.int {
	if msgFuncDE422FADFunc != nil {
		msgde422fad := packPCharString(cmsg)
		ctxde422fad := (unsafe.Pointer)(unsafe.Pointer(cctx))
		retde422fad := msgFuncDE422FADFunc(msgde422fad, ctxde422fad)
		ret, _ := (C.int)(retde422fad), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var msgFuncDE422FADFunc MsgFunc

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}
