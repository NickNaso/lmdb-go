// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 29 Feb 2016 20:47:06 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package mdb

/*
#include "lmdb.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocValMemory allocates memory for type C.MDB_val in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValValue = unsafe.Sizeof([1]C.MDB_val{})

// Ref returns a reference.
func (x *Val) Ref() *C.MDB_val {
	if x == nil {
		return nil
	}
	return x.reff5baf417
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Val) Free() {
	if x != nil && x.allocsf5baf417 != nil {
		x.allocsf5baf417.(*cgoAllocMap).Free()
		x.reff5baf417 = nil
	}
}

// NewValRef initialises a new struct holding the reference to the originaitng C struct.
func NewValRef(ref *C.MDB_val) *Val {
	if ref == nil {
		return nil
	}
	obj := new(Val)
	obj.reff5baf417 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Val) PassRef() (*C.MDB_val, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff5baf417 != nil {
		return x.reff5baf417, nil
	}
	memf5baf417 := allocValMemory(1)
	reff5baf417 := (*C.MDB_val)(memf5baf417)
	allocsf5baf417 := new(cgoAllocMap)
	var cmv_size_allocs *cgoAllocMap
	reff5baf417.mv_size, cmv_size_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocsf5baf417.Borrow(cmv_size_allocs)

	var cmv_data_allocs *cgoAllocMap
	reff5baf417.mv_data, cmv_data_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsf5baf417.Borrow(cmv_data_allocs)

	x.reff5baf417 = reff5baf417
	x.allocsf5baf417 = allocsf5baf417
	return reff5baf417, allocsf5baf417

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Val) PassValue() (C.MDB_val, *cgoAllocMap) {
	if x == nil {
		x = NewValRef(nil)
	} else if x.reff5baf417 != nil {
		return *x.reff5baf417, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Val) Deref() {
	if x.reff5baf417 == nil {
		return
	}
	x.Size = (uint)(x.reff5baf417.mv_size)
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.reff5baf417.mv_data))
}

// PassRef returns a reference.
func (x CmpFunc) PassRef() (ref *C.MDB_cmp_func, allocs *cgoAllocMap) {
	if cmpFunc15AEA10FFunc == nil {
		cmpFunc15AEA10FFunc = x
	}
	return (*C.MDB_cmp_func)(C.MDB_cmp_func_15aea10f), nil
}

//export cmpFunc15AEA10F
func cmpFunc15AEA10F(ca *C.MDB_val, cb *C.MDB_val) C.int {
	if cmpFunc15AEA10FFunc != nil {
		a := NewValRef(ca)
		b := NewValRef(cb)
		ret15aea10f := cmpFunc15AEA10FFunc(a, b)
		ret, _ := (C.int)(ret15aea10f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var cmpFunc15AEA10FFunc CmpFunc

// PassRef returns a reference.
func (x RelFunc) PassRef() (ref *C.MDB_rel_func, allocs *cgoAllocMap) {
	if relFunc3A9876A5Func == nil {
		relFunc3A9876A5Func = x
	}
	return (*C.MDB_rel_func)(C.MDB_rel_func_3a9876a5), nil
}

//export relFunc3A9876A5
func relFunc3A9876A5(citem *C.MDB_val, coldptr unsafe.Pointer, cnewptr unsafe.Pointer, crelctx unsafe.Pointer) {
	if relFunc3A9876A5Func != nil {
		item := NewValRef(citem)
		oldptr := (unsafe.Pointer)(unsafe.Pointer(coldptr))
		newptr := (unsafe.Pointer)(unsafe.Pointer(cnewptr))
		relctx := (unsafe.Pointer)(unsafe.Pointer(crelctx))
		relFunc3A9876A5Func(item, oldptr, newptr, relctx)
	}
	panic("callback func has not been set (race?)")
}

var relFunc3A9876A5Func RelFunc

// allocStatsMemory allocates memory for type C.MDB_stat in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStatsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStatsValue = unsafe.Sizeof([1]C.MDB_stat{})

// Ref returns a reference.
func (x *Stats) Ref() *C.MDB_stat {
	if x == nil {
		return nil
	}
	return x.ref9ed18a7f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Stats) Free() {
	if x != nil && x.allocs9ed18a7f != nil {
		x.allocs9ed18a7f.(*cgoAllocMap).Free()
		x.ref9ed18a7f = nil
	}
}

// NewStatsRef initialises a new struct holding the reference to the originaitng C struct.
func NewStatsRef(ref *C.MDB_stat) *Stats {
	if ref == nil {
		return nil
	}
	obj := new(Stats)
	obj.ref9ed18a7f = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Stats) PassRef() (*C.MDB_stat, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9ed18a7f != nil {
		return x.ref9ed18a7f, nil
	}
	mem9ed18a7f := allocStatsMemory(1)
	ref9ed18a7f := (*C.MDB_stat)(mem9ed18a7f)
	allocs9ed18a7f := new(cgoAllocMap)
	var cms_psize_allocs *cgoAllocMap
	ref9ed18a7f.ms_psize, cms_psize_allocs = (C.uint)(x.Psize), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_psize_allocs)

	var cms_depth_allocs *cgoAllocMap
	ref9ed18a7f.ms_depth, cms_depth_allocs = (C.uint)(x.Depth), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_depth_allocs)

	var cms_branch_pages_allocs *cgoAllocMap
	ref9ed18a7f.ms_branch_pages, cms_branch_pages_allocs = (C.mdb_size_t)(x.BranchPages), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_branch_pages_allocs)

	var cms_leaf_pages_allocs *cgoAllocMap
	ref9ed18a7f.ms_leaf_pages, cms_leaf_pages_allocs = (C.mdb_size_t)(x.LeafPages), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_leaf_pages_allocs)

	var cms_overflow_pages_allocs *cgoAllocMap
	ref9ed18a7f.ms_overflow_pages, cms_overflow_pages_allocs = (C.mdb_size_t)(x.OverflowPages), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_overflow_pages_allocs)

	var cms_entries_allocs *cgoAllocMap
	ref9ed18a7f.ms_entries, cms_entries_allocs = (C.mdb_size_t)(x.Entries), cgoAllocsUnknown
	allocs9ed18a7f.Borrow(cms_entries_allocs)

	x.ref9ed18a7f = ref9ed18a7f
	x.allocs9ed18a7f = allocs9ed18a7f
	return ref9ed18a7f, allocs9ed18a7f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Stats) PassValue() (C.MDB_stat, *cgoAllocMap) {
	if x == nil {
		x = NewStatsRef(nil)
	} else if x.ref9ed18a7f != nil {
		return *x.ref9ed18a7f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Stats) Deref() {
	if x.ref9ed18a7f == nil {
		return
	}
	x.Psize = (uint32)(x.ref9ed18a7f.ms_psize)
	x.Depth = (uint32)(x.ref9ed18a7f.ms_depth)
	x.BranchPages = (Size)(x.ref9ed18a7f.ms_branch_pages)
	x.LeafPages = (Size)(x.ref9ed18a7f.ms_leaf_pages)
	x.OverflowPages = (Size)(x.ref9ed18a7f.ms_overflow_pages)
	x.Entries = (Size)(x.ref9ed18a7f.ms_entries)
}

// allocEnvinfoMemory allocates memory for type C.MDB_envinfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEnvinfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEnvinfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEnvinfoValue = unsafe.Sizeof([1]C.MDB_envinfo{})

// Ref returns a reference.
func (x *Envinfo) Ref() *C.MDB_envinfo {
	if x == nil {
		return nil
	}
	return x.refea477e79
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Envinfo) Free() {
	if x != nil && x.allocsea477e79 != nil {
		x.allocsea477e79.(*cgoAllocMap).Free()
		x.refea477e79 = nil
	}
}

// NewEnvinfoRef initialises a new struct holding the reference to the originaitng C struct.
func NewEnvinfoRef(ref *C.MDB_envinfo) *Envinfo {
	if ref == nil {
		return nil
	}
	obj := new(Envinfo)
	obj.refea477e79 = ref
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Envinfo) PassRef() (*C.MDB_envinfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea477e79 != nil {
		return x.refea477e79, nil
	}
	memea477e79 := allocEnvinfoMemory(1)
	refea477e79 := (*C.MDB_envinfo)(memea477e79)
	allocsea477e79 := new(cgoAllocMap)
	var cme_mapaddr_allocs *cgoAllocMap
	refea477e79.me_mapaddr, cme_mapaddr_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Mapaddr)), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_mapaddr_allocs)

	var cme_mapsize_allocs *cgoAllocMap
	refea477e79.me_mapsize, cme_mapsize_allocs = (C.mdb_size_t)(x.Mapsize), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_mapsize_allocs)

	var cme_last_pgno_allocs *cgoAllocMap
	refea477e79.me_last_pgno, cme_last_pgno_allocs = (C.mdb_size_t)(x.LastPgno), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_last_pgno_allocs)

	var cme_last_txnid_allocs *cgoAllocMap
	refea477e79.me_last_txnid, cme_last_txnid_allocs = (C.mdb_size_t)(x.LastTxnid), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_last_txnid_allocs)

	var cme_maxreaders_allocs *cgoAllocMap
	refea477e79.me_maxreaders, cme_maxreaders_allocs = (C.uint)(x.Maxreaders), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_maxreaders_allocs)

	var cme_numreaders_allocs *cgoAllocMap
	refea477e79.me_numreaders, cme_numreaders_allocs = (C.uint)(x.Numreaders), cgoAllocsUnknown
	allocsea477e79.Borrow(cme_numreaders_allocs)

	x.refea477e79 = refea477e79
	x.allocsea477e79 = allocsea477e79
	return refea477e79, allocsea477e79

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Envinfo) PassValue() (C.MDB_envinfo, *cgoAllocMap) {
	if x == nil {
		x = NewEnvinfoRef(nil)
	} else if x.refea477e79 != nil {
		return *x.refea477e79, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Envinfo) Deref() {
	if x.refea477e79 == nil {
		return
	}
	x.Mapaddr = (unsafe.Pointer)(unsafe.Pointer(x.refea477e79.me_mapaddr))
	x.Mapsize = (Size)(x.refea477e79.me_mapsize)
	x.LastPgno = (Size)(x.refea477e79.me_last_pgno)
	x.LastTxnid = (Size)(x.refea477e79.me_last_txnid)
	x.Maxreaders = (uint32)(x.refea477e79.me_maxreaders)
	x.Numreaders = (uint32)(x.refea477e79.me_numreaders)
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// PassRef returns a reference.
func (x AssertFunc) PassRef() (ref *C.MDB_assert_func, allocs *cgoAllocMap) {
	if assertFunc635F7C32Func == nil {
		assertFunc635F7C32Func = x
	}
	return (*C.MDB_assert_func)(C.MDB_assert_func_635f7c32), nil
}

//export assertFunc635F7C32
func assertFunc635F7C32(cenv *C.MDB_env, cmsg *C.char) {
	if assertFunc635F7C32Func != nil {
		env := (*Env)(unsafe.Pointer(cenv))
		msg := packPCharString(cmsg)
		assertFunc635F7C32Func(env, msg)
	}
	panic("callback func has not been set (race?)")
}

var assertFunc635F7C32Func AssertFunc

// PassRef returns a reference.
func (x MsgFunc) PassRef() (ref *C.MDB_msg_func, allocs *cgoAllocMap) {
	if msgFunc86D0DCEFFunc == nil {
		msgFunc86D0DCEFFunc = x
	}
	return (*C.MDB_msg_func)(C.MDB_msg_func_86d0dcef), nil
}

//export msgFunc86D0DCEF
func msgFunc86D0DCEF(cmsg *C.char, cctx unsafe.Pointer) C.int {
	if msgFunc86D0DCEFFunc != nil {
		msg := packPCharString(cmsg)
		ctx := (unsafe.Pointer)(unsafe.Pointer(cctx))
		ret86d0dcef := msgFunc86D0DCEFFunc(msg, ctx)
		ret, _ := (C.int)(ret86d0dcef), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var msgFunc86D0DCEFFunc MsgFunc

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}
